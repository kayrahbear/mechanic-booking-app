from fastapi import APIRouter, Query, Depends, HTTPException
from datetime import date, timedelta, datetime
from typing import Optional
from ..models import Slot, AvailabilitySeedRequest, AvailabilitySeedResult, DaySchedule, Mechanic
from ..utils.slots import build_slots
from ..auth import get_scheduler_or_mechanic_user, User
from ..firestore import get_client
from tenacity import retry, retry_if_exception_type, stop_after_attempt, wait_exponential
from google.api_core.exceptions import ServiceUnavailable, Aborted
from google.cloud import firestore

router = APIRouter(prefix="/availability", tags=["availability"])

@router.get("", response_model=list[Slot])
async def get_availability(
    date: date = Query(..., description="Date to get availability for (YYYY-MM-DD)"),
    service_id: Optional[str] = Query(None, description="Filter by service ID to show only mechanics who can perform this service")
):
    """
    Get availability for a specific day. This endpoint now generates availability
    dynamically based on mechanic schedules and existing bookings, with optional caching.
    Supports filtering by service_id to show only relevant mechanics.
    """
    db = get_client()
    if not db:
        return []

    # Generate cache key that includes service_id for service-specific caching
    cache_key = f"{date.isoformat()}"
    if service_id:
        cache_key += f"_service_{service_id}"

    # First, try to get cached availability
    cached_availability = await _get_cached_availability(db, date, service_id)
    if cached_availability:
        return cached_availability
    
    # Generate availability dynamically
    availability = await _generate_availability_for_day(db, date, service_id)
    
    # Cache the generated availability
    await _cache_availability(db, date, availability, service_id)
    
    return availability


async def _get_cached_availability(db, day: date, service_id: Optional[str] = None) -> list[Slot] | None:
    """Check if we have cached availability for the given day."""
    # For service-specific requests, we don't use cache for now to ensure accuracy
    # This could be optimized later with service-specific caching
    if service_id:
        return None
        
    doc = db.collection("availability").document(day.isoformat()).get()
    if not doc.exists:
        return None
    
    data = doc.to_dict()
    
    # Skip cache if it was generated by old seeding method (not dynamic)
    if not data.get("generated_dynamically", False):
        return None
    
    # Check if cache is still valid (1 hour TTL)
    cache_time = data.get("cached_at")
    if cache_time:
        cache_age = datetime.utcnow() - cache_time.replace(tzinfo=None)
        if cache_age.total_seconds() > 3600:  # 1 hour TTL
            return None
    
    # Convert cached slots to Slot objects
    slots_data = data.get("slots", {})
    mechanics_data = data.get("mechanics", {})
    slots = []
    for time_str, status in slots_data.items():
        start_iso = f"{day}T{time_str}:00"
        # Find mechanic for this slot (simplified - take first available)
        mechanic_id = next(iter(mechanics_data.keys())) if mechanics_data else None
        slots.append(Slot(
            start=start_iso, 
            end=start_iso, 
            is_free=(status == "free"),
            mechanic_id=mechanic_id if status == "free" else None
        ))
    
    return slots


async def _generate_availability_for_day(db, day: date, service_id: Optional[str] = None) -> list[Slot]:
    """Generate availability for a day based on mechanic schedules and existing bookings."""
    # Get active mechanics, optionally filtered by service specialties
    mechanics_query = db.collection("mechanics").where("active", "==", True)
    
    # If service_id is provided, filter mechanics who can perform this service
    if service_id:
        mechanics_query = mechanics_query.where("specialties", "array-contains", service_id)
    
    mechanics = []
    for doc in mechanics_query.stream():
        data = doc.to_dict()
        data["id"] = doc.id
        mechanics.append(Mechanic(**data))
    
    if not mechanics:
        return []
    
    # Get day of week for schedule lookup
    weekday_names = ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]
    weekday = weekday_names[day.weekday()]
    
    # Generate all possible slots from all mechanics
    all_slots = {}  # time_str -> {"status": "free", "mechanic_id": mechanic_id}
    
    for mechanic in mechanics:
        day_schedule = getattr(mechanic.schedule, weekday)
        if not day_schedule or not day_schedule.start or not day_schedule.end:
            continue
            
        # Generate slots for this mechanic's schedule
        slot_map = build_slots(day_schedule.start, day_schedule.end)
        for time_str in slot_map.keys():
            if time_str not in all_slots:
                all_slots[time_str] = {"status": "free", "mechanic_id": mechanic.id}
    
    # Check existing bookings for this day to mark slots as booked
    day_start = datetime.combine(day, datetime.min.time())
    day_end = datetime.combine(day, datetime.max.time())
    
    bookings_query = db.collection("bookings").where(
        "slot_start", ">=", day_start
    ).where(
        "slot_start", "<=", day_end
    ).where(
        "status", "in", ["pending", "confirmed"]
    ).stream()
    
    for booking_doc in bookings_query:
        booking_data = booking_doc.to_dict()
        booking_start = booking_data["slot_start"]
        if isinstance(booking_start, str):
            booking_start = datetime.fromisoformat(booking_start.replace('Z', '+00:00'))
        
        # Mark the corresponding slot as booked
        time_str = booking_start.strftime("%H:%M")
        if time_str in all_slots:
            all_slots[time_str]["status"] = "booked"
    
    # Convert to Slot objects
    slots = []
    for time_str, slot_data in all_slots.items():
        start_iso = f"{day}T{time_str}:00"
        slots.append(Slot(
            start=start_iso,
            end=start_iso,
            is_free=(slot_data["status"] == "free"),
            mechanic_id=slot_data["mechanic_id"] if slot_data["status"] == "free" else None
        ))
    
    # Sort slots by time
    slots.sort(key=lambda s: s.start)
    return slots


async def _cache_availability(db, day: date, slots: list[Slot], service_id: Optional[str] = None):
    """Cache the generated availability for performance."""
    # Don't cache service-specific results for now to keep it simple
    if service_id:
        return
        
    # Convert slots back to the storage format
    slots_map = {}
    mechanics_map = {}
    
    for slot in slots:
        time_str = datetime.fromisoformat(slot.start.replace('Z', '')).strftime("%H:%M")
        slots_map[time_str] = "free" if slot.is_free else "booked"
        if slot.mechanic_id:
            mechanics_map[slot.mechanic_id] = True
    
    # Store in Firestore with cache timestamp
    doc_ref = db.collection("availability").document(day.isoformat())
    doc_ref.set({
        "day": day.isoformat(),
        "slots": slots_map,
        "mechanics": mechanics_map,
        "cached_at": firestore.SERVER_TIMESTAMP,
        "generated_dynamically": True,
        "created_at": firestore.SERVER_TIMESTAMP,
        "updated_at": firestore.SERVER_TIMESTAMP,
    })

# Define the transactional function outside the endpoint, decorated
@firestore.transactional
def _update_availability_in_transaction(transaction, doc_ref, slot_map, mech_id, day_date):
    """
    Executes the document create/update logic within a Firestore transaction.
    Returns tuple: (created: bool, updated: bool)
    """
    snap = doc_ref.get(transaction=transaction)
    if not snap.exists:
        # Create new doc
        transaction.set(
            doc_ref,
            {
                "day": day_date.isoformat(),
                "slots": slot_map,
                "mechanics": {mech_id: True},
                "created_at": firestore.SERVER_TIMESTAMP,
                "updated_at": firestore.SERVER_TIMESTAMP,
            },
        )
        return True, False  # Created
    else:
        # Update existing doc
        data = snap.to_dict()
        merged_slots = data.get("slots", {})
        for key, val in slot_map.items():
            # Only overwrite if slot not present or not booked
            if merged_slots.get(key) in (None, "free", "blocked"):
                merged_slots[key] = val
        mechanics_map = data.get("mechanics", {})
        mechanics_map[mech_id] = True
        transaction.update(
            doc_ref,
            {
                "slots": merged_slots,
                "mechanics": mechanics_map,
                "updated_at": firestore.SERVER_TIMESTAMP,
            },
        )
        return False, True # Updated


# The main endpoint function
@router.post("/seed", response_model=AvailabilitySeedResult, status_code=202)
@retry(
    retry=retry_if_exception_type((ServiceUnavailable, Aborted)),
    wait=wait_exponential(multiplier=0.5, max=30),
    stop=stop_after_attempt(5),
)
async def seed_availability(
    req: AvailabilitySeedRequest,
    user: User = Depends(get_scheduler_or_mechanic_user),
):
    """Generate availability documents for a week based on mechanics schedules.
    This route can be triggered by Cloud Scheduler (system) or a mechanic/admin.
    """

    db = get_client()
    if not db:
        raise HTTPException(500, "Firestore client not initialised")

    # Determine week start (Monday)
    today = datetime.utcnow().date()
    if req.week_start:
        week_start = req.week_start
    else:
        # find next Monday relative to today
        days_ahead = (7 - today.weekday()) % 7  # Monday=0
        days_ahead = 7 if days_ahead == 0 else days_ahead
        week_start = today + timedelta(days=days_ahead)

    created = updated = skipped = 0

    mechanics_cur = db.collection("mechanics").where("active", "==", True).stream()
    mechanics: list[Mechanic] = []
    for doc in mechanics_cur:
        data = doc.to_dict()
        data["id"] = doc.id
        mechanics.append(Mechanic(**data))

    # Build date list Monday-Sunday
    days = [week_start + timedelta(days=i) for i in range(7)]
    # Remove batch creation - no longer needed
    # batch = db.batch()

    # Remove the outer day loop as transaction is per mechanic/day now
    # for day in days:
    #    day_doc = db.collection("availability").document(day.isoformat())
    #    day_data = day_doc.get().to_dict() if day_doc.get().exists else None

    # For each mechanic, build/merge slots per day
    for mech in mechanics:
        for idx, day_date in enumerate(days):
            weekday = ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"][
                idx
            ]
            day_sched: DaySchedule | None = getattr(mech.schedule, weekday)
            if not day_sched or not day_sched.start or not day_sched.end:
                skipped += 1
                continue

            if req.dry_run:
                skipped += 1
                continue # Skip Firestore interaction in dry run

            slot_map = build_slots(day_sched.start, day_sched.end)
            doc_ref = db.collection("availability").document(day_date.isoformat())

            # Create a transaction object for each attempt
            transaction = db.transaction()
            # Call the decorated function, passing the transaction object
            try:
                created_flag, updated_flag = _update_availability_in_transaction(
                    transaction, doc_ref, slot_map, mech.id, day_date
                )
                if created_flag:
                    created += 1
                if updated_flag:
                    updated += 1
            except Exception as e:
                # Log or handle transaction errors if needed, although tenacity should retry
                print(f"Transaction attempt failed for {mech.id} on {day_date}: {e}")
                # Depending on retry logic, might need to re-raise or handle differently
                raise # Re-raise to allow tenacity to handle retries

    # Removed the final check for dry_run as it's handled inside the loop
    # if not req.dry_run:
    #    pass # transactions executed inline above

    return AvailabilitySeedResult(
        week_start=week_start,
        created=created,
        updated=updated,
        skipped=skipped,
        dry_run=req.dry_run,
    )
